( mcforth decompiler )
decimal

\ cheesy decompiler
: cee ' >name 32 dump ;

\ build opcode table
create ops 256 cells allot
       ops 256 cells erase

: op ( op )  here swap cells ops + !  bl word c@ 1+ allot ;

include see.info

: op? ( op -- c-str t | 0 ) cells ops + @ ?dup ;

: .op ( op )  op? if count type else ." unused" then space ;

: .ops  256 0 do  i op? if i . count type space then  loop ;

hex

: .b  base @ hex  swap 0 <# # # #> type space  base ! ;
: .name ( xt -- ) >name count 1f and type space ;

: .call  ( a -- a+2 ) dup w@ ( dup . ) .name 2 + ;
: .call32  ( a -- a+4 ) dup @ ( dup . ) .name cell+ ;
: .branch ( a -- a+1 )  dup dup c@ dup 80 and if ffffff00 or then + . 1+ ;
: .lit  dup ? cell + ;
: .slit  count 2dup type '"' emit space + ;

\ now we need to know how many bytes of operand per opcode. hmm...
: .operands ( a opc -- a' )
    \ case?
    dup 1 = if drop .call exit then
    dup 2 = if drop .call32 exit then
    dup 3 8 within over 50 60 within or if drop .branch exit then
    dup 8 = over 20 30 within or if drop .lit exit then
    dup A D within if drop .slit exit then
    drop ;

: (see) ( xt -- )
    \ dup >name count 1f and type
    begin
        dup . dup count ( a a+1 op )
        dup .b dup .op .operands cr
        swap c@ dup 0= swap 10 20 within or
    until drop ;

: see ' (see) ;

decimal
